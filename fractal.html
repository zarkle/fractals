<!DOCTYPE html>
<html>
<head>
  <title>Julia Fractals</title>
</head>

<style>
  body {
    background: black;
    color: white;
  }
  canvas {
    border: 1px solid white;
  }
</style>

<body>
  <h2></h2>
  <canvas></canvas>
</body>

<!-- Import math.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/5.6.0/math.min.js"></script>

<script>

// The HTML elements we are using
var header = document.querySelector('h2')
var canvas = document.querySelector('canvas')
var ctx = canvas.getContext('2d')

// The size of our canvas
var width = 200
var height = 200

// Set the size of our canvas
canvas.width = width
canvas.height = height

// The XY coordinates of the mouse over the canvas
var mouseX = 0
var mouseY = 0

// The point we use for C in our Julia Set equation
var constant = math.complex(0.28, 0.01)

// Turn a point on the complex plane into a color
function pointToColor(point) {
  var red = point.re*255
  var green = point.im*255
  return `rgb(${red}, ${green}, 0)`
}

// Turn XY pixel coordinates into a point on the complex plane
function pixelToPoint(x, y) {
  // Map percentage of total width/height to a value from -1 to +1
  var zx = (x/width)*2-1
  var zy = 1-(y/height)*2

  // Create a complex number based on our new XY values
  return math.complex(zx, zy)
}

// Update the elements that need to change
function update() {
  header.innerHTML = constant.toString()
}

// What to do when the mouse moves over the canvas
function move(event) {
  // Get the mouse's XY coordinates on canvas
  mouseX = event.clientX-canvas.offsetLeft
  mouseY = event.clientY-canvas.offsetTop

  // Turn mouse coordinates into a point on the complex plane
  constant = pixelToPoint(mouseX, mouseY)

  // Round that point off to the nearest 0.01
  constant.re = math.round(constant.re*100)/100
  constant.im = math.round(constant.im*100)/100

  // Update everything!
  update()
}

// Trigger move every time the mouse moves over canvas
canvas.addEventListener('pointermove', move)

</script>
</html>
